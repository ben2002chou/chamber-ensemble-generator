"""Automatic audio loudness normalization and mixing procedure, adapted from SLAKH dataset."""

import numpy as np
import os
import glob
import pyloudnorm as pyln
import librosa
from tqdm import tqdm
import argparse

from utils.file_utils import pickle_load, pickle_dump
from midi_ddsp.utils.audio_io import save_wav
from utils.file_utils import get_config


def audio_normalization(
    data_dir, output_dir, normalization_factor, target_peak, sample_rate
):
    # https://github.com/ethman/slakh-generation/blob/e6454eb57a3683b99cdd16695fe652f83b75bb14/render_by_instrument.py#L439

    # if output_dir is provided, then save to the output_dir.
    if output_dir:
        output_dir = os.path.join(output_dir, os.path.basename(data_dir))
        os.makedirs(output_dir, exist_ok=True)
    else:  # else, change in place
        output_dir = data_dir

    # load metadata
    pickle_path = os.path.join(data_dir, "metadata.pickle")
    metadata = pickle_load(pickle_path)

    wav_files = glob.glob(f"{data_dir}/*.wav")
    stem_wav_files = [f for f in wav_files if "mix.wav" not in f]  # exclude mix wav
    all_audio = []
    for wav_file in stem_wav_files:
        wav, _ = librosa.load(wav_file, sr=sample_rate, mono=True)
        all_audio.append(wav)

    meter = pyln.Meter(sample_rate)
    target_gain = np.power(10.0, target_peak / 20.0)
    loudnesses = [meter.integrated_loudness(a) for a in all_audio]
    metadata["stem_integrated_loudness"] = {
        j: float(loudnesses[j]) for j in range(len(loudnesses))
    }
    if np.any(np.isinf(loudnesses)):
        raise RuntimeError("One or more sources have -inf loudness!")

    normalized_audio = [
        pyln.normalize.loudness(a, loudnesses[j], normalization_factor)
        for j, a in enumerate(all_audio)
    ]
    mixture = np.sum(normalized_audio, axis=0)

    peak = np.max(np.abs(mixture))
    if peak >= target_gain:
        gain = target_gain / peak
        mixture *= gain

        if np.any(np.isnan(mixture)):
            raise RuntimeError("This mixture contains NaNs!!!")

        normalized_audio = [a * gain for a in normalized_audio]

        metadata["overall_gain"] = float(gain)

    else:
        metadata["overall_gain"] = 1.0

    metadata["normalization_factor"] = normalization_factor
    metadata["target_peak"] = target_peak
    metadata["normalized"] = True

    # save metadata
    pickle_dump(metadata, os.path.join(output_dir, "metadata.pickle"))

    # save stem
    for i, wav_file in enumerate(stem_wav_files):
        save_wav(
            normalized_audio[i],
            os.path.join(output_dir, os.path.basename(wav_file)),
            sample_rate=sample_rate,
        )

    # save mix
    save_wav(mixture, os.path.join(output_dir, "mix.wav"), sample_rate=sample_rate)


def audio_normalization_main(
    synthesis_dir=None, multi_synthesis_dir=None, output_dir=None
):
    """
    Performs audio normalization on directories generated by MIDI-DDSP synthesis.

    Parameters:
    - synthesis_dir (str): The directory generated by MIDI-DDSP synthesis. Mutually exclusive with multi_synthesis_dir.
    - multi_synthesis_dir (str): The directory containing multiple folders generated by MIDI-DDSP synthesis. Mutually exclusive with synthesis_dir.
    - output_dir (str): The directory where the output will be stored.

    Returns:
    None
    """
    # Assuming get_config() and audio_normalization() are defined elsewhere in your script
    config = get_config()

    # Initialize list to hold directories for processing
    synth_dir_list = []

    # Determine the synthesis directory(s) to process
    if synthesis_dir:
        synth_dir_list = [synthesis_dir]
    elif multi_synthesis_dir:
        synth_dir_list = glob.glob(f"{multi_synthesis_dir}/*/")

    # Process each directory
    for synth_dir in tqdm(synth_dir_list):
        audio_normalization(
            synth_dir,
            output_dir,
            normalization_factor=config["mix_normalization_factor"],
            target_peak=config["mix_target_peak"],
            sample_rate=config["sample_rate"],
        )


# Example of how to call the function directly if needed
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Audio Normalization")
    group = parser.add_mutually_exclusive_group()
    group.add_argument(
        "--synthesis_dir",
        type=str,
        default=None,
        metavar="N",
        help="the directory generated by MIDI-DDSP synthesis.",
    )
    group.add_argument(
        "--multi_synthesis_dir",
        type=str,
        default=None,
        metavar="N",
        help="the directory containing multiple folders generated by MIDI-DDSP synthesis.",
    )
    parser.add_argument(
        "--output_dir",
        type=str,
        default=None,
        metavar="N",
        help="the directory for output.",
    )
    args = parser.parse_args()

    # Call the function with arguments from the command line
    audio_normalization_main(
        args.synthesis_dir, args.multi_synthesis_dir, args.output_dir
    )
